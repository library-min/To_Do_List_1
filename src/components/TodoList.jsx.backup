import { useState, useEffect } from 'react';
import ThemeToggle from './ThemeToggle';
import GameStats from './GameStats';
import PomodoroTimer from './PomodoroTimer';
import Statistics from './Statistics';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import {
  useSortable,
} from '@dnd-kit/sortable';
import {CSS} from '@dnd-kit/utilities';
import './TodoList.css';

function SortableItem({ todo, onToggle, onDelete, onArchive, onDuplicate, onStartPomodoro, onStartEditing, editingId, editingText, setEditingText, saveEdit, handleEditKeyPress }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: todo.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'ÎÜíÏùå': return 'var(--color-error)';
      case 'Î≥¥ÌÜµ': return 'var(--color-warning)';
      case 'ÎÇÆÏùå': return 'var(--color-success)';
      default: return 'var(--color-gray-500)';
    }
  };

  const getPriorityIcon = (priority) => {
    switch (priority) {
      case 'ÎÜíÏùå': return 'üî¥';
      case 'Î≥¥ÌÜµ': return 'üü°';
      case 'ÎÇÆÏùå': return 'üü¢';
      default: return '‚ö™';
    }
  };

  const formatDate = (dateString) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('ko-KR');
  };

  const getDueDateStatus = (dateString) => {
    if (!dateString) return null;
    const dueDate = new Date(dateString);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    dueDate.setHours(0, 0, 0, 0);
    
    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
    
    if (diffDays < 0) return 'overdue';
    if (diffDays === 0) return 'today';
    if (diffDays === 1) return 'tomorrow';
    if (diffDays <= 3) return 'soon';
    return 'normal';
  };

  const dueDateStatus = getDueDateStatus(todo.dueDate);

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`todo-item-card bounce-enter ${todo.completed ? 'completed' : ''} ${dueDateStatus ? `due-${dueDateStatus}` : ''}`}
    >
      <div className="todo-header">
        <div className="todo-main">
          <div className="drag-handle" {...attributes} {...listeners}>
            ‚ãÆ‚ãÆ
          </div>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => onToggle(todo.id)}
            className="todo-checkbox"
          />
          {editingId === todo.id ? (
            <input
              type="text"
              value={editingText}
              onChange={(e) => setEditingText(e.target.value)}
              onKeyDown={handleEditKeyPress}
              onBlur={saveEdit}
              className="todo-edit-input"
              autoFocus
            />
          ) : (
            <span 
              className="todo-text"
              onDoubleClick={() => !todo.completed && onStartEditing(todo.id, todo.text)}
            >
              {todo.emoji && <span className="todo-emoji">{todo.emoji}</span>}
              {todo.text}
            </span>
          )}
        </div>
        <div className="todo-actions">
          {!todo.completed && (
            <button 
              onClick={() => onStartPomodoro(todo)}
              className="pomodoro-button"
              title="ÎΩÄÎ™®ÎèÑÎ°ú ÏãúÏûë"
            >
              üçÖ
            </button>
          )}
          <button 
            onClick={() => onDuplicate(todo.id)}
            className="duplicate-button"
            title="Ìï† Ïùº Î≥µÏ†ú"
          >
            üìã
          </button>
          {todo.completed && (
            <button 
              onClick={() => onArchive(todo.id)}
              className="archive-button"
              title="ÏïÑÏπ¥Ïù¥Î∏åÎ°ú Ïù¥Îèô"
            >
              üì¶
            </button>
          )}
          <button 
            onClick={() => onDelete(todo.id)}
            className="delete-button"
          >
            ÏÇ≠Ï†ú
          </button>
        </div>
      </div>
      
      <div className="todo-details">
        <div className="todo-meta">
          <span 
            className="priority-badge"
            style={{ backgroundColor: getPriorityColor(todo.priority) }}
          >
            {getPriorityIcon(todo.priority)} {todo.priority}
          </span>
          {todo.dueDate && (
            <span className={`due-date ${dueDateStatus ? `due-${dueDateStatus}` : ''}`}>
              üìÖ {formatDate(todo.dueDate)}
              {dueDateStatus === 'overdue' && ' (ÏßÄÎÇ¨Ïùå)'}
              {dueDateStatus === 'today' && ' (Ïò§Îäò)'}
              {dueDateStatus === 'tomorrow' && ' (ÎÇ¥Ïùº)'}
              {dueDateStatus === 'soon' && ' (Í≥ß)'}
            </span>
          )}
        </div>
      </div>
    </div>
  );
}

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [priority, setPriority] = useState('Î≥¥ÌÜµ');
  const [dueDate, setDueDate] = useState('');
  const [timeEstimate, setTimeEstimate] = useState('');
  const [dependsOn, setDependsOn] = useState('');
  const [eisenhowerQuadrant, setEisenhowerQuadrant] = useState('important-urgent');
  const [selectedEmoji, setSelectedEmoji] = useState('');
  
  // Gamification
  const [points, setPoints] = useState(() => parseInt(localStorage.getItem('todoPoints')) || 0);
  const [level, setLevel] = useState(() => Math.floor(points / 100) + 1);
  const [badges, setBadges] = useState(() => JSON.parse(localStorage.getItem('todoBadges')) || []);
  
  // Pomodoro
  const [showPomodoro, setShowPomodoro] = useState(false);
  const [currentTask, setCurrentTask] = useState(null);
  
  // Editing
  const [editingId, setEditingId] = useState(null);
  const [editingText, setEditingText] = useState('');
  
  // Visibility
  const [showCompleted, setShowCompleted] = useState(true);
  
  // Archive
  const [archivedTodos, setArchivedTodos] = useState(() => JSON.parse(localStorage.getItem('archivedTodos')) || []);
  const [showArchive, setShowArchive] = useState(false);
  
  // Statistics
  const [showStatistics, setShowStatistics] = useState(false);
  
  // Search
  const [searchQuery, setSearchQuery] = useState('');
  
  // Drag and Drop
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  useEffect(() => {
    localStorage.setItem('todoPoints', points.toString());
    const newLevel = Math.floor(points / 100) + 1;
    setLevel(newLevel);
    checkBadges();
  }, [points]);

  useEffect(() => {
    localStorage.setItem('todoBadges', JSON.stringify(badges));
  }, [badges]);

  useEffect(() => {
    localStorage.setItem('archivedTodos', JSON.stringify(archivedTodos));
  }, [archivedTodos]);

  const checkBadges = () => {
    const completedTodos = todos.filter(todo => todo.completed);
    const newBadges = [];

    // Ï≤´ Ìï† Ïùº ÏôÑÎ£å Î±ÉÏßÄ
    if (completedTodos.length >= 1 && !badges.find(b => b.id === 'first-task')) {
      newBadges.push({ id: 'first-task', icon: 'üéØ', name: 'Ï≤´ Í±∏Ïùå', description: 'Ï≤´ Î≤àÏß∏ Ìï† Ïùº ÏôÑÎ£å' });
    }

    // 10Í∞ú ÏôÑÎ£å Î±ÉÏßÄ
    if (completedTodos.length >= 10 && !badges.find(b => b.id === 'ten-tasks')) {
      newBadges.push({ id: 'ten-tasks', icon: 'üèÜ', name: 'ÏÑ±Ïã§Ìï®', description: '10Í∞ú Ìï† Ïùº ÏôÑÎ£å' });
    }

    // Ïó∞ÏÜç 3Ïùº Î±ÉÏßÄ (Í∞ÑÎã® Íµ¨ÌòÑ)
    if (points >= 150 && !badges.find(b => b.id === 'streak-3')) {
      newBadges.push({ id: 'streak-3', icon: 'üî•', name: 'Ïó∞ÏÜç ÏôÑÏ£º', description: '3Ïùº Ïó∞ÏÜç ÌôúÎèô' });
    }

    if (newBadges.length > 0) {
      setBadges(prev => [...prev, ...newBadges]);
    }
  };

  const addTodo = () => {
    if (inputValue.trim() !== '') {
      const newTodo = {
        id: Date.now(),
        text: inputValue,
        priority: priority,
        dueDate: dueDate,
        timeEstimate: timeEstimate,
        dependsOn: dependsOn,
        eisenhowerQuadrant: eisenhowerQuadrant,
        emoji: selectedEmoji,
        completed: false,
        createdAt: new Date().toISOString()
      };

      // Ï¢ÖÏÜçÏÑ± Ï≤¥ÌÅ¨
      if (dependsOn) {
        const dependentTask = todos.find(t => t.id === parseInt(dependsOn));
        if (dependentTask && !dependentTask.completed) {
          newTodo.blocked = true;
        }
      }

      setTodos([...todos, newTodo]);
      setInputValue('');
      setPriority('Î≥¥ÌÜµ');
      setDueDate('');
      setTimeEstimate('');
      setDependsOn('');
      setEisenhowerQuadrant('important-urgent');
      setSelectedEmoji('');
    }
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  const toggleTodo = (id) => {
    const todo = todos.find(t => t.id === id);
    if (!todo.completed) {
      // Ìï† Ïùº ÏôÑÎ£åÏãú Ìè¨Ïù∏Ìä∏ ÏßÄÍ∏â
      let earnedPoints = 10;
      
      // Ïö∞ÏÑ†ÏàúÏúÑÎ≥Ñ Î≥¥ÎÑàÏä§
      if (todo.priority === 'ÎÜíÏùå') earnedPoints += 10;
      else if (todo.priority === 'Î≥¥ÌÜµ') earnedPoints += 5;
      
      // ÏïÑÏù¥Ï††ÌïòÏõå Îß§Ìä∏Î¶≠Ïä§Î≥Ñ Î≥¥ÎÑàÏä§
      if (todo.eisenhowerQuadrant === 'important-urgent') earnedPoints += 15;
      else if (todo.eisenhowerQuadrant === 'important-not-urgent') earnedPoints += 10;
      
      setPoints(prev => prev + earnedPoints);
    }

    setTodos(todos.map(todo => {
      if (todo.id === id) {
        const updatedTodo = { ...todo, completed: !todo.completed };
        
        // ÏôÑÎ£åÏãú Ï¢ÖÏÜçÎêú Îã§Î•∏ Ìï† ÏùºÎì§Ïùò blocked ÏÉÅÌÉú Ìï¥Ï†ú
        if (updatedTodo.completed) {
          setTodos(prevTodos => 
            prevTodos.map(t => 
              t.dependsOn === id.toString() ? { ...t, blocked: false } : t
            )
          );
        }
        
        return updatedTodo;
      }
      return todo;
    }));
  };

  const startPomodoro = (todo) => {
    setCurrentTask(todo);
    setShowPomodoro(true);
  };

  const completePomodoroSession = () => {
    setPoints(prev => prev + 25); // ÎΩÄÎ™®ÎèÑÎ°ú ÏôÑÎ£å Î≥¥ÎÑàÏä§
    setShowPomodoro(false);
    setCurrentTask(null);
  };

  const startEditing = (id, text) => {
    setEditingId(id);
    setEditingText(text);
  };

  const saveEdit = () => {
    if (editingText.trim() !== '') {
      setTodos(todos.map(todo => 
        todo.id === editingId 
          ? { ...todo, text: editingText.trim() }
          : todo
      ));
    }
    setEditingId(null);
    setEditingText('');
  };

  const cancelEdit = () => {
    setEditingId(null);
    setEditingText('');
  };

  const handleEditKeyPress = (e) => {
    if (e.key === 'Enter') {
      saveEdit();
    } else if (e.key === 'Escape') {
      cancelEdit();
    }
  };

  const handleDragEnd = (event) => {
    const { active, over } = event;

    if (active.id !== over.id) {
      setTodos((items) => {
        const oldIndex = items.findIndex(item => item.id === active.id);
        const newIndex = items.findIndex(item => item.id === over.id);
        
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      addTodo();
    }
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'ÎÜíÏùå': return 'var(--color-error)';
      case 'Î≥¥ÌÜµ': return 'var(--color-warning)';
      case 'ÎÇÆÏùå': return 'var(--color-success)';
      default: return 'var(--color-gray-500)';
    }
  };

  const getEisenhowerInfo = (quadrant) => {
    switch (quadrant) {
      case 'important-urgent':
        return { text: 'Ï§ëÏöîÌïòÍ≥† Í∏¥Í∏â', color: '#ef4444', icon: 'üî•' };
      case 'important-not-urgent':
        return { text: 'Ï§ëÏöîÌïòÏßÄÎßå Ïó¨Ïú†', color: '#f59e0b', icon: 'üìã' };
      case 'not-important-urgent':
        return { text: 'Í∏¥Í∏âÌïòÏßÄÎßå Îçú Ï§ëÏöî', color: '#06b6d4', icon: '‚ö°' };
      case 'not-important-not-urgent':
        return { text: 'Ïó¨Ïú†Î°≠Í≥† Îçú Ï§ëÏöî', color: '#84cc16', icon: 'üìù' };
      default:
        return { text: '', color: '', icon: '' };
    }
  };

  const formatDate = (dateString) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('ko-KR');
  };

  const getAvailableTodos = () => {
    return todos.filter(todo => !todo.completed);
  };

  const sortTodosByQuadrant = (todos) => {
    const quadrantOrder = ['important-urgent', 'important-not-urgent', 'not-important-urgent', 'not-important-not-urgent'];
    return todos.sort((a, b) => quadrantOrder.indexOf(a.eisenhowerQuadrant) - quadrantOrder.indexOf(b.eisenhowerQuadrant));
  };

  const getVisibleTodos = () => {
    let filteredTodos = showCompleted ? todos : todos.filter(todo => !todo.completed);
    
    if (searchQuery.trim()) {
      filteredTodos = filteredTodos.filter(todo => 
        todo.text.toLowerCase().includes(searchQuery.toLowerCase()) ||
        todo.priority.toLowerCase().includes(searchQuery.toLowerCase()) ||
        (todo.emoji && todo.emoji.includes(searchQuery))
      );
    }
    
    return filteredTodos;
  };

  const archiveTodo = (id) => {
    const todoToArchive = todos.find(todo => todo.id === id);
    if (todoToArchive) {
      setArchivedTodos(prev => [...prev, { ...todoToArchive, archivedAt: new Date().toISOString() }]);
      setTodos(todos.filter(todo => todo.id !== id));
    }
  };

  const restoreFromArchive = (id) => {
    const todoToRestore = archivedTodos.find(todo => todo.id === id);
    if (todoToRestore) {
      const { archivedAt, ...todoWithoutArchiveDate } = todoToRestore;
      setTodos(prev => [...prev, todoWithoutArchiveDate]);
      setArchivedTodos(archivedTodos.filter(todo => todo.id !== id));
    }
  };

  const deleteFromArchive = (id) => {
    setArchivedTodos(archivedTodos.filter(todo => todo.id !== id));
  };

  const duplicateTodo = (id) => {
    const todoToDuplicate = todos.find(todo => todo.id === id);
    if (todoToDuplicate) {
      const duplicatedTodo = {
        ...todoToDuplicate,
        id: Date.now(),
        text: `${todoToDuplicate.text} (Î≥µÏÇ¨Î≥∏)`,
        completed: false,
        createdAt: new Date().toISOString()
      };
      setTodos([...todos, duplicatedTodo]);
    }
  };

  return (
    <div className="app-container">
      <div className="top-bar">
        <div className="top-bar-content">
          <h1 className="app-title">üìã Smart Todo</h1>
          <ThemeToggle />
        </div>
      </div>
      
      <div className="todo-app card">
        <div className="app-header">
          <h1 className="todo-title">Ìï† Ïùº Í¥ÄÎ¶¨</h1>
          <div className="header-controls">
            <button 
              onClick={() => setShowStatistics(!showStatistics)}
              className={`stats-toggle ${showStatistics ? 'active' : ''}`}
            >
              üìä ÌÜµÍ≥Ñ
            </button>
          </div>
        </div>
        
        <div className="main-content">
          <GameStats 
            points={points} 
            level={level} 
            badges={badges}
          />

          {showStatistics && (
            <Statistics todos={todos} archivedTodos={archivedTodos} />
          )}

          <div className="todo-section card">
            <div className="todo-form">
              <div className="form-group">
                <label className="form-label">Ìï† Ïùº</label>
                <input
                  type="text"
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyPress={handleKeyPress}
                  placeholder="ÏÉàÎ°úÏö¥ Ìï† ÏùºÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî..."
                  className="todo-input"
                />
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label className="form-label">Ï§ëÏöîÎèÑ</label>
                  <select
                    value={priority}
                    onChange={(e) => setPriority(e.target.value)}
                    className="priority-select"
                  >
                    <option value="ÎÇÆÏùå">ÎÇÆÏùå</option>
                    <option value="Î≥¥ÌÜµ">Î≥¥ÌÜµ</option>
                    <option value="ÎÜíÏùå">ÎÜíÏùå</option>
                  </select>
                </div>

                <div className="form-group">
                  <label className="form-label">ÎßàÍ∞êÏùº</label>
                  <input
                    type="date"
                    value={dueDate}
                    onChange={(e) => setDueDate(e.target.value)}
                    className="date-input"
                  />
                </div>
              </div>

              <div className="form-group">
                <label className="form-label">Ïù¥Î™®ÏßÄ (ÏÑ†ÌÉùÏÇ¨Ìï≠)</label>
                <div className="emoji-selector">
                  <input
                    type="text"
                    value={selectedEmoji}
                    onChange={(e) => setSelectedEmoji(e.target.value)}
                    placeholder="Ïù¥Î™®ÏßÄ ÏûÖÎ†• ÎòêÎäî ÏÑ†ÌÉù..."
                    className="emoji-input"
                    maxLength="2"
                  />
                  <div className="emoji-presets">
                    {['üìù', 'üíº', 'üè†', 'üéØ', 'üí°', 'üìö', 'üí™', 'üéµ', 'üçï', 'üéÆ', '‚úàÔ∏è', 'üíª', 'üìû', 'üõí', 'üèÉ‚Äç‚ôÇÔ∏è', 'üé®', 'üì±', 'üí≥'].map(emoji => (
                      <button
                        key={emoji}
                        type="button"
                        onClick={() => setSelectedEmoji(emoji)}
                        className={`emoji-preset ${selectedEmoji === emoji ? 'selected' : ''}`}
                      >
                        {emoji}
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              <div className="form-actions">
                <button onClick={addTodo} className="add-button primary-button">
                  ‚úÖ Ìï† Ïùº Ï∂îÍ∞Ä
                </button>
                {todos.length > 0 && (
                  <button 
                    onClick={() => setTodos([])} 
                    className="clear-all-button danger-button"
                  >
                    üóëÔ∏è Î™®Îëê ÏÇ≠Ï†ú
                  </button>
                )}
              </div>
            </div>

            <div className="search-and-controls">
              <div className="search-container">
                <input
                  type="text"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  placeholder="Ìï† Ïùº Í≤ÄÏÉâ... (Ï†úÎ™©, Ïö∞ÏÑ†ÏàúÏúÑ, Ïù¥Î™®ÏßÄ)"
                  className="search-input"
                />
                <span className="search-icon">üîç</span>
                {searchQuery && (
                  <button 
                    onClick={() => setSearchQuery('')}
                    className="clear-search"
                  >
                    ‚úï
                  </button>
                )}
              </div>

              {todos.some(todo => todo.completed) && (
                <div className="visibility-controls">
                  <button 
                    onClick={() => setShowCompleted(!showCompleted)}
                    className={`visibility-toggle ${showCompleted ? 'active' : ''}`}
                  >
                    {showCompleted ? '‚úÖ ÏôÑÎ£åÎêú Ìï† Ïùº Ïà®Í∏∞Í∏∞' : 'üëÅÔ∏è ÏôÑÎ£åÎêú Ìï† Ïùº Î≥¥Í∏∞'}
                  </button>
                </div>
              )}
            </div>

            <div className="todo-list">
          {getVisibleTodos().length === 0 ? (
            <p className="empty-message">
              {searchQuery.trim() 
                ? `"${searchQuery}"Ïóê ÎåÄÌïú Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.`
                : todos.length === 0 
                  ? 'Ìï† ÏùºÏù¥ ÏóÜÏäµÎãàÎã§. ÏÉàÎ°úÏö¥ Ìï† ÏùºÏùÑ Ï∂îÍ∞ÄÌï¥Î≥¥ÏÑ∏Ïöî!' 
                  : showCompleted 
                    ? 'Ìï† ÏùºÏù¥ ÏóÜÏäµÎãàÎã§.' 
                    : 'ÏôÑÎ£åÎêòÏßÄ ÏïäÏùÄ Ìï† ÏùºÏù¥ ÏóÜÏäµÎãàÎã§!'}
            </p>
          ) : (
            <DndContext
              sensors={sensors}
              collisionDetection={closestCenter}
              onDragEnd={handleDragEnd}
            >
              <SortableContext items={getVisibleTodos().map(todo => todo.id)} strategy={verticalListSortingStrategy}>
                {getVisibleTodos().map(todo => (
                  <SortableItem
                    key={todo.id}
                    todo={todo}
                    onToggle={toggleTodo}
                    onDelete={deleteTodo}
                    onArchive={archiveTodo}
                    onDuplicate={duplicateTodo}
                    onStartPomodoro={startPomodoro}
                    onStartEditing={startEditing}
                    editingId={editingId}
                    editingText={editingText}
                    setEditingText={setEditingText}
                    saveEdit={saveEdit}
                    handleEditKeyPress={handleEditKeyPress}
                  />
                ))}
              </SortableContext>
            </DndContext>
          )}
        </div>

        {todos.length > 0 && (
          <div className="todo-counter">
            <div className="counter-item">
              <span className="counter-number">{todos.filter(todo => !todo.completed).length}</span>
              <span className="counter-label">ÎÇ®ÏùÄ Ìï† Ïùº</span>
            </div>
            <div className="counter-item">
              <span className="counter-number">{todos.filter(todo => todo.completed).length}</span>
              <span className="counter-label">ÏôÑÎ£å</span>
            </div>
            <div className="counter-item">
              <span className="counter-number">{todos.length}</span>
              <span className="counter-label">Ï†ÑÏ≤¥</span>
            </div>
          </div>
        )}
      </div>

      {archivedTodos.length > 0 && (
          <div className="archive-section">
            <button 
              onClick={() => setShowArchive(!showArchive)}
              className={`archive-toggle ${showArchive ? 'active' : ''}`}
            >
              üì¶ ÏïÑÏπ¥Ïù¥Î∏å ({archivedTodos.length})
            </button>
            
            {showArchive && (
              <div className="archive-list">
                {archivedTodos.map(todo => (
                  <div key={todo.id} className="archive-item">
                    <div className="archive-content">
                      <span className="archive-text">{todo.text}</span>
                      <span className="archive-date">
                        {new Date(todo.archivedAt).toLocaleDateString('ko-KR')}Ïóê Î≥¥Í¥ÄÎê®
                      </span>
                    </div>
                    <div className="archive-actions">
                      <button 
                        onClick={() => restoreFromArchive(todo.id)}
                        className="restore-button"
                        title="Î≥µÏõê"
                      >
                        ‚Ü©Ô∏è
                      </button>
                      <button 
                        onClick={() => deleteFromArchive(todo.id)}
                        className="delete-button"
                        title="ÏòÅÍµ¨ ÏÇ≠Ï†ú"
                      >
                        üóëÔ∏è
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

      {showPomodoro && currentTask && (
        <PomodoroTimer
          taskName={currentTask.text}
          onComplete={completePomodoroSession}
          onClose={() => setShowPomodoro(false)}
        />
      )}
      </div>
    </div>
  );
}

export default TodoList;