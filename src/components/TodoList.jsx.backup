import { useState, useEffect } from 'react';
import ThemeToggle from './ThemeToggle';
import GameStats from './GameStats';
import PomodoroTimer from './PomodoroTimer';
import Statistics from './Statistics';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import {
  useSortable,
} from '@dnd-kit/sortable';
import {CSS} from '@dnd-kit/utilities';
import './TodoList.css';

function SortableItem({ todo, onToggle, onDelete, onArchive, onDuplicate, onStartPomodoro, onStartEditing, editingId, editingText, setEditingText, saveEdit, handleEditKeyPress }) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: todo.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'ë†’ìŒ': return 'var(--color-error)';
      case 'ë³´í†µ': return 'var(--color-warning)';
      case 'ë‚®ìŒ': return 'var(--color-success)';
      default: return 'var(--color-gray-500)';
    }
  };

  const getPriorityIcon = (priority) => {
    switch (priority) {
      case 'ë†’ìŒ': return 'ğŸ”´';
      case 'ë³´í†µ': return 'ğŸŸ¡';
      case 'ë‚®ìŒ': return 'ğŸŸ¢';
      default: return 'âšª';
    }
  };

  const formatDate = (dateString) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('ko-KR');
  };

  const getDueDateStatus = (dateString) => {
    if (!dateString) return null;
    const dueDate = new Date(dateString);
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    dueDate.setHours(0, 0, 0, 0);
    
    const diffDays = Math.ceil((dueDate - today) / (1000 * 60 * 60 * 24));
    
    if (diffDays < 0) return 'overdue';
    if (diffDays === 0) return 'today';
    if (diffDays === 1) return 'tomorrow';
    if (diffDays <= 3) return 'soon';
    return 'normal';
  };

  const dueDateStatus = getDueDateStatus(todo.dueDate);

  return (
    <div
      ref={setNodeRef}
      style={style}
      className={`todo-item-card bounce-enter ${todo.completed ? 'completed' : ''} ${dueDateStatus ? `due-${dueDateStatus}` : ''}`}
    >
      <div className="todo-header">
        <div className="todo-main">
          <div className="drag-handle" {...attributes} {...listeners}>
            â‹®â‹®
          </div>
          <input
            type="checkbox"
            checked={todo.completed}
            onChange={() => onToggle(todo.id)}
            className="todo-checkbox"
          />
          {editingId === todo.id ? (
            <input
              type="text"
              value={editingText}
              onChange={(e) => setEditingText(e.target.value)}
              onKeyDown={handleEditKeyPress}
              onBlur={saveEdit}
              className="todo-edit-input"
              autoFocus
            />
          ) : (
            <span 
              className="todo-text"
              onDoubleClick={() => !todo.completed && onStartEditing(todo.id, todo.text)}
            >
              {todo.emoji && <span className="todo-emoji">{todo.emoji}</span>}
              {todo.text}
            </span>
          )}
        </div>
        <div className="todo-actions">
          {!todo.completed && (
            <button 
              onClick={() => onStartPomodoro(todo)}
              className="pomodoro-button"
              title="ë½€ëª¨ë„ë¡œ ì‹œì‘"
            >
              ğŸ…
            </button>
          )}
          <button 
            onClick={() => onDuplicate(todo.id)}
            className="duplicate-button"
            title="í•  ì¼ ë³µì œ"
          >
            ğŸ“‹
          </button>
          {todo.completed && (
            <button 
              onClick={() => onArchive(todo.id)}
              className="archive-button"
              title="ì•„ì¹´ì´ë¸Œë¡œ ì´ë™"
            >
              ğŸ“¦
            </button>
          )}
          <button 
            onClick={() => onDelete(todo.id)}
            className="delete-button"
          >
            ì‚­ì œ
          </button>
        </div>
      </div>
      
      <div className="todo-details">
        <div className="todo-meta">
          <span 
            className="priority-badge"
            style={{ backgroundColor: getPriorityColor(todo.priority) }}
          >
            {getPriorityIcon(todo.priority)} {todo.priority}
          </span>
          {todo.dueDate && (
            <span className={`due-date ${dueDateStatus ? `due-${dueDateStatus}` : ''}`}>
              ğŸ“… {formatDate(todo.dueDate)}
              {dueDateStatus === 'overdue' && ' (ì§€ë‚¬ìŒ)'}
              {dueDateStatus === 'today' && ' (ì˜¤ëŠ˜)'}
              {dueDateStatus === 'tomorrow' && ' (ë‚´ì¼)'}
              {dueDateStatus === 'soon' && ' (ê³§)'}
            </span>
          )}
        </div>
      </div>
    </div>
  );
}

function TodoList() {
  const [todos, setTodos] = useState([]);
  const [inputValue, setInputValue] = useState('');
  const [priority, setPriority] = useState('ë³´í†µ');
  const [dueDate, setDueDate] = useState('');
  const [timeEstimate, setTimeEstimate] = useState('');
  const [dependsOn, setDependsOn] = useState('');
  const [eisenhowerQuadrant, setEisenhowerQuadrant] = useState('important-urgent');
  const [selectedEmoji, setSelectedEmoji] = useState('');
  
  // Gamification
  const [points, setPoints] = useState(() => parseInt(localStorage.getItem('todoPoints')) || 0);
  const [level, setLevel] = useState(() => Math.floor(points / 100) + 1);
  const [badges, setBadges] = useState(() => JSON.parse(localStorage.getItem('todoBadges')) || []);
  
  // Pomodoro
  const [showPomodoro, setShowPomodoro] = useState(false);
  const [currentTask, setCurrentTask] = useState(null);
  
  // Editing
  const [editingId, setEditingId] = useState(null);
  const [editingText, setEditingText] = useState('');
  
  // Visibility
  const [showCompleted, setShowCompleted] = useState(true);
  
  // Archive
  const [archivedTodos, setArchivedTodos] = useState(() => JSON.parse(localStorage.getItem('archivedTodos')) || []);
  const [showArchive, setShowArchive] = useState(false);
  
  // Statistics
  const [showStatistics, setShowStatistics] = useState(false);
  
  // Search
  const [searchQuery, setSearchQuery] = useState('');
  
  // Drag and Drop
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  useEffect(() => {
    localStorage.setItem('todoPoints', points.toString());
    const newLevel = Math.floor(points / 100) + 1;
    setLevel(newLevel);
    checkBadges();
  }, [points]);

  useEffect(() => {
    localStorage.setItem('todoBadges', JSON.stringify(badges));
  }, [badges]);

  useEffect(() => {
    localStorage.setItem('archivedTodos', JSON.stringify(archivedTodos));
  }, [archivedTodos]);

  const checkBadges = () => {
    const completedTodos = todos.filter(todo => todo.completed);
    const newBadges = [];

    // ì²« í•  ì¼ ì™„ë£Œ ë±ƒì§€
    if (completedTodos.length >= 1 && !badges.find(b => b.id === 'first-task')) {
      newBadges.push({ id: 'first-task', icon: 'ğŸ¯', name: 'ì²« ê±¸ìŒ', description: 'ì²« ë²ˆì§¸ í•  ì¼ ì™„ë£Œ' });
    }

    // 10ê°œ ì™„ë£Œ ë±ƒì§€
    if (completedTodos.length >= 10 && !badges.find(b => b.id === 'ten-tasks')) {
      newBadges.push({ id: 'ten-tasks', icon: 'ğŸ†', name: 'ì„±ì‹¤í•¨', description: '10ê°œ í•  ì¼ ì™„ë£Œ' });
    }

    // ì—°ì† 3ì¼ ë±ƒì§€ (ê°„ë‹¨ êµ¬í˜„)
    if (points >= 150 && !badges.find(b => b.id === 'streak-3')) {
      newBadges.push({ id: 'streak-3', icon: 'ğŸ”¥', name: 'ì—°ì† ì™„ì£¼', description: '3ì¼ ì—°ì† í™œë™' });
    }

    if (newBadges.length > 0) {
      setBadges(prev => [...prev, ...newBadges]);
    }
  };

  const addTodo = () => {
    if (inputValue.trim() !== '') {
      const newTodo = {
        id: Date.now(),
        text: inputValue,
        priority: priority,
        dueDate: dueDate,
        timeEstimate: timeEstimate,
        dependsOn: dependsOn,
        eisenhowerQuadrant: eisenhowerQuadrant,
        emoji: selectedEmoji,
        completed: false,
        createdAt: new Date().toISOString()
      };

      // ì¢…ì†ì„± ì²´í¬
      if (dependsOn) {
        const dependentTask = todos.find(t => t.id === parseInt(dependsOn));
        if (dependentTask && !dependentTask.completed) {
          newTodo.blocked = true;
        }
      }

      setTodos([...todos, newTodo]);
      setInputValue('');
      setPriority('ë³´í†µ');
      setDueDate('');
      setTimeEstimate('');
      setDependsOn('');
      setEisenhowerQuadrant('important-urgent');
      setSelectedEmoji('');
    }
  };

  const deleteTodo = (id) => {
    setTodos(todos.filter(todo => todo.id !== id));
  };

  const toggleTodo = (id) => {
    const todo = todos.find(t => t.id === id);
    if (!todo.completed) {
      // í•  ì¼ ì™„ë£Œì‹œ í¬ì¸íŠ¸ ì§€ê¸‰
      let earnedPoints = 10;
      
      // ìš°ì„ ìˆœìœ„ë³„ ë³´ë„ˆìŠ¤
      if (todo.priority === 'ë†’ìŒ') earnedPoints += 10;
      else if (todo.priority === 'ë³´í†µ') earnedPoints += 5;
      
      // ì•„ì´ì  í•˜ì›Œ ë§¤íŠ¸ë¦­ìŠ¤ë³„ ë³´ë„ˆìŠ¤
      if (todo.eisenhowerQuadrant === 'important-urgent') earnedPoints += 15;
      else if (todo.eisenhowerQuadrant === 'important-not-urgent') earnedPoints += 10;
      
      setPoints(prev => prev + earnedPoints);
    }

    setTodos(todos.map(todo => {
      if (todo.id === id) {
        const updatedTodo = { ...todo, completed: !todo.completed };
        
        // ì™„ë£Œì‹œ ì¢…ì†ëœ ë‹¤ë¥¸ í•  ì¼ë“¤ì˜ blocked ìƒíƒœ í•´ì œ
        if (updatedTodo.completed) {
          setTodos(prevTodos => 
            prevTodos.map(t => 
              t.dependsOn === id.toString() ? { ...t, blocked: false } : t
            )
          );
        }
        
        return updatedTodo;
      }
      return todo;
    }));
  };

  const startPomodoro = (todo) => {
    setCurrentTask(todo);
    setShowPomodoro(true);
  };

  const completePomodoroSession = () => {
    setPoints(prev => prev + 25); // ë½€ëª¨ë„ë¡œ ì™„ë£Œ ë³´ë„ˆìŠ¤
    setShowPomodoro(false);
    setCurrentTask(null);
  };

  const startEditing = (id, text) => {
    setEditingId(id);
    setEditingText(text);
  };

  const saveEdit = () => {
    if (editingText.trim() !== '') {
      setTodos(todos.map(todo => 
        todo.id === editingId 
          ? { ...todo, text: editingText.trim() }
          : todo
      ));
    }
    setEditingId(null);
    setEditingText('');
  };

  const cancelEdit = () => {
    setEditingId(null);
    setEditingText('');
  };

  const handleEditKeyPress = (e) => {
    if (e.key === 'Enter') {
      saveEdit();
    } else if (e.key === 'Escape') {
      cancelEdit();
    }
  };

  const handleDragEnd = (event) => {
    const { active, over } = event;

    if (active.id !== over.id) {
      setTodos((items) => {
        const oldIndex = items.findIndex(item => item.id === active.id);
        const newIndex = items.findIndex(item => item.id === over.id);
        
        return arrayMove(items, oldIndex, newIndex);
      });
    }
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      addTodo();
    }
  };

  const getPriorityColor = (priority) => {
    switch (priority) {
      case 'ë†’ìŒ': return 'var(--color-error)';
      case 'ë³´í†µ': return 'var(--color-warning)';
      case 'ë‚®ìŒ': return 'var(--color-success)';
      default: return 'var(--color-gray-500)';
    }
  };

  const getEisenhowerInfo = (quadrant) => {
    switch (quadrant) {
      case 'important-urgent':
        return { text: 'ì¤‘ìš”í•˜ê³  ê¸´ê¸‰', color: '#ef4444', icon: 'ğŸ”¥' };
      case 'important-not-urgent':
        return { text: 'ì¤‘ìš”í•˜ì§€ë§Œ ì—¬ìœ ', color: '#f59e0b', icon: 'ğŸ“‹' };
      case 'not-important-urgent':
        return { text: 'ê¸´ê¸‰í•˜ì§€ë§Œ ëœ ì¤‘ìš”', color: '#06b6d4', icon: 'âš¡' };
      case 'not-important-not-urgent':
        return { text: 'ì—¬ìœ ë¡­ê³  ëœ ì¤‘ìš”', color: '#84cc16', icon: 'ğŸ“' };
      default:
        return { text: '', color: '', icon: '' };
    }
  };

  const formatDate = (dateString) => {
    if (!dateString) return '';
    const date = new Date(dateString);
    return date.toLocaleDateString('ko-KR');
  };

  const getAvailableTodos = () => {
    return todos.filter(todo => !todo.completed);
  };

  const sortTodosByQuadrant = (todos) => {
    const quadrantOrder = ['important-urgent', 'important-not-urgent', 'not-important-urgent', 'not-important-not-urgent'];
    return todos.sort((a, b) => quadrantOrder.indexOf(a.eisenhowerQuadrant) - quadrantOrder.indexOf(b.eisenhowerQuadrant));
  };

  const getVisibleTodos = () => {
    let filteredTodos = showCompleted ? todos : todos.filter(todo => !todo.completed);
    
    if (searchQuery.trim()) {
      filteredTodos = filteredTodos.filter(todo => 
        todo.text.toLowerCase().includes(searchQuery.toLowerCase()) ||
        todo.priority.toLowerCase().includes(searchQuery.toLowerCase()) ||
        (todo.emoji && todo.emoji.includes(searchQuery))
      );
    }
    
    return filteredTodos;
  };

  const archiveTodo = (id) => {
    const todoToArchive = todos.find(todo => todo.id === id);
    if (todoToArchive) {
      setArchivedTodos(prev => [...prev, { ...todoToArchive, archivedAt: new Date().toISOString() }]);
      setTodos(todos.filter(todo => todo.id !== id));
    }
  };

  const restoreFromArchive = (id) => {
    const todoToRestore = archivedTodos.find(todo => todo.id === id);
    if (todoToRestore) {
      const { archivedAt, ...todoWithoutArchiveDate } = todoToRestore;
      setTodos(prev => [...prev, todoWithoutArchiveDate]);
      setArchivedTodos(archivedTodos.filter(todo => todo.id !== id));
    }
  };

  const deleteFromArchive = (id) => {
    setArchivedTodos(archivedTodos.filter(todo => todo.id !== id));
  };

  const duplicateTodo = (id) => {
    const todoToDuplicate = todos.find(todo => todo.id === id);
    if (todoToDuplicate) {
      const duplicatedTodo = {
        ...todoToDuplicate,
        id: Date.now(),
        text: `${todoToDuplicate.text} (ë³µì‚¬ë³¸)`,
        completed: false,
        createdAt: new Date().toISOString()
      };
      setTodos([...todos, duplicatedTodo]);
    }
  };

  return (
    <div className="app-container">
      <div className="top-bar">
        <div className="top-bar-content">
          <h1 className="app-title">ğŸ“‹ Smart Todo</h1>
          <ThemeToggle />
        </div>
      </div>
      
      <div className="todo-app card">
        <div className="app-header">
          <h1 className="todo-title">í•  ì¼ ê´€ë¦¬</h1>
          <div className="header-controls">
            <button 
              onClick={() => setShowStatistics(!showStatistics)}
              className={`stats-toggle ${showStatistics ? 'active' : ''}`}
            >
              ğŸ“Š í†µê³„
            </button>
          </div>
        </div>
        
        <div className="main-content">
          <GameStats 
            points={points} 
            level={level} 
            badges={badges}
          />

          {showStatistics && (
            <Statistics todos={todos} archivedTodos={archivedTodos} />
          )}

          <div className="todo-section card">
            <div className="todo-form">
              <div className="form-group">
                <label className="form-label">í•  ì¼</label>
                <input
                  type="text"
                  value={inputValue}
                  onChange={(e) => setInputValue(e.target.value)}
                  onKeyPress={handleKeyPress}
                  placeholder="ìƒˆë¡œìš´ í•  ì¼ì„ ì…ë ¥í•˜ì„¸ìš”..."
                  className="todo-input"
                />
              </div>

              <div className="form-row">
                <div className="form-group">
                  <label className="form-label">ì¤‘ìš”ë„</label>
                  <select
                    value={priority}
                    onChange={(e) => setPriority(e.target.value)}
                    className="priority-select"
                  >
                    <option value="ë‚®ìŒ">ë‚®ìŒ</option>
                    <option value="ë³´í†µ">ë³´í†µ</option>
                    <option value="ë†’ìŒ">ë†’ìŒ</option>
                  </select>
                </div>

                <div className="form-group">
                  <label className="form-label">ë§ˆê°ì¼</label>
                  <input
                    type="date"
                    value={dueDate}
                    onChange={(e) => setDueDate(e.target.value)}
                    className="date-input"
                  />
                </div>
              </div>

              <div className="form-group">
                <label className="form-label">ì´ëª¨ì§€ (ì„ íƒì‚¬í•­)</label>
                <div className="emoji-selector">
                  <input
                    type="text"
                    value={selectedEmoji}
                    onChange={(e) => setSelectedEmoji(e.target.value)}
                    placeholder="ì´ëª¨ì§€ ì…ë ¥ ë˜ëŠ” ì„ íƒ..."
                    className="emoji-input"
                    maxLength="2"
                  />
                  <div className="emoji-presets">
                    {['ğŸ“', 'ğŸ’¼', 'ğŸ ', 'ğŸ¯', 'ğŸ’¡', 'ğŸ“š', 'ğŸ’ª', 'ğŸµ', 'ğŸ•', 'ğŸ®', 'âœˆï¸', 'ğŸ’»', 'ğŸ“', 'ğŸ›’', 'ğŸƒâ€â™‚ï¸', 'ğŸ¨', 'ğŸ“±', 'ğŸ’³'].map(emoji => (
                      <button
                        key={emoji}
                        type="button"
                        onClick={() => setSelectedEmoji(emoji)}
                        className={`emoji-preset ${selectedEmoji === emoji ? 'selected' : ''}`}
                      >
                        {emoji}
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              <div className="form-actions">
                <button onClick={addTodo} className="add-button primary-button">
                  âœ… í•  ì¼ ì¶”ê°€
                </button>
                {todos.length > 0 && (
                  <button 
                    onClick={() => setTodos([])} 
                    className="clear-all-button danger-button"
                  >
                    ğŸ—‘ï¸ ëª¨ë‘ ì‚­ì œ
                  </button>
                )}
              </div>
            </div>

            <div className="search-and-controls">
              <div className="search-container">
                <input
                  type="text"
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  placeholder="í•  ì¼ ê²€ìƒ‰... (ì œëª©, ìš°ì„ ìˆœìœ„, ì´ëª¨ì§€)"
                  className="search-input"
                />
                <span className="search-icon">ğŸ”</span>
                {searchQuery && (
                  <button 
                    onClick={() => setSearchQuery('')}
                    className="clear-search"
                  >
                    âœ•
                  </button>
                )}
              </div>

              {todos.some(todo => todo.completed) && (
                <div className="visibility-controls">
                  <button 
                    onClick={() => setShowCompleted(!showCompleted)}
                    className={`visibility-toggle ${showCompleted ? 'active' : ''}`}
                  >
                    {showCompleted ? 'âœ… ì™„ë£Œëœ í•  ì¼ ìˆ¨ê¸°ê¸°' : 'ğŸ‘ï¸ ì™„ë£Œëœ í•  ì¼ ë³´ê¸°'}
                  </button>
                </div>
              )}
            </div>

            <div className="todo-list">
          {getVisibleTodos().length === 0 ? (
            <p className="empty-message">
              {searchQuery.trim() 
                ? `"${searchQuery}"ì— ëŒ€í•œ ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.`
                : todos.length === 0 
                  ? 'í•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ í•  ì¼ì„ ì¶”ê°€í•´ë³´ì„¸ìš”!' 
                  : showCompleted 
                    ? 'í•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤.' 
                    : 'ì™„ë£Œë˜ì§€ ì•Šì€ í•  ì¼ì´ ì—†ìŠµë‹ˆë‹¤!'}
            </p>
          ) : (
            <DndContext
              sensors={sensors}
              collisionDetection={closestCenter}
              onDragEnd={handleDragEnd}
            >
              <SortableContext items={getVisibleTodos().map(todo => todo.id)} strategy={verticalListSortingStrategy}>
                {getVisibleTodos().map(todo => (
                  <SortableItem
                    key={todo.id}
                    todo={todo}
                    onToggle={toggleTodo}
                    onDelete={deleteTodo}
                    onArchive={archiveTodo}
                    onDuplicate={duplicateTodo}
                    onStartPomodoro={startPomodoro}
                    onStartEditing={startEditing}
                    editingId={editingId}
                    editingText={editingText}
                    setEditingText={setEditingText}
                    saveEdit={saveEdit}
                    handleEditKeyPress={handleEditKeyPress}
                  />
                ))}
              </SortableContext>
            </DndContext>
          )}
        </div>

        {todos.length > 0 && (
          <div className="todo-counter">
            <div className="counter-item">
              <span className="counter-number">{todos.filter(todo => !todo.completed).length}</span>
              <span className="counter-label">ë‚¨ì€ í•  ì¼</span>
            </div>
            <div className="counter-item">
              <span className="counter-number">{todos.filter(todo => todo.completed).length}</span>
              <span className="counter-label">ì™„ë£Œ</span>
            </div>
            <div className="counter-item">
              <span className="counter-number">{todos.length}</span>
              <span className="counter-label">ì „ì²´</span>
            </div>
          </div>
        )}
      </div>

      {archivedTodos.length > 0 && (
          <div className="archive-section">
            <button 
              onClick={() => setShowArchive(!showArchive)}
              className={`archive-toggle ${showArchive ? 'active' : ''}`}
            >
              ğŸ“¦ ì•„ì¹´ì´ë¸Œ ({archivedTodos.length})
            </button>
            
            {showArchive && (
              <div className="archive-list">
                {archivedTodos.map(todo => (
                  <div key={todo.id} className="archive-item">
                    <div className="archive-content">
                      <span className="archive-text">{todo.text}</span>
                      <span className="archive-date">
                        {new Date(todo.archivedAt).toLocaleDateString('ko-KR')}ì— ë³´ê´€ë¨
                      </span>
                    </div>
                    <div className="archive-actions">
                      <button 
                        onClick={() => restoreFromArchive(todo.id)}
                        className="restore-button"
                        title="ë³µì›"
                      >
                        â†©ï¸
                      </button>
                      <button 
                        onClick={() => deleteFromArchive(todo.id)}
                        className="delete-button"
                        title="ì˜êµ¬ ì‚­ì œ"
                      >
                        ğŸ—‘ï¸
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

      {showPomodoro && currentTask && (
        <PomodoroTimer
          taskName={currentTask.text}
          onComplete={completePomodoroSession}
          onClose={() => setShowPomodoro(false)}
        />
      )}
      </div>
    </div>
  );
}

export default TodoList;